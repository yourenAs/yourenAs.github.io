{"meta":{"title":"YourenAs","subtitle":null,"description":null,"author":"YourenAs","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"总结，目标","slug":"总结，目标","date":"2019-04-13T14:36:10.000Z","updated":"2019-04-13T15:38:43.764Z","comments":true,"path":"2019/04/13/总结，目标/","link":"","permalink":"http://yoursite.com/2019/04/13/总结，目标/","excerpt":"&emsp;&emsp;对自己这一个多月以来的回顾，还有对自己现状的剖析，以及今后该如何去做。","text":"&emsp;&emsp;对自己这一个多月以来的回顾，还有对自己现状的剖析，以及今后该如何去做。 一、回顾&emsp;&emsp;转眼春招开始已经一个多月了，自己除了接到腾讯一家面试之外，好像再都没了。说来也惭愧，被腾讯捞了又捞还是没能走到HR,自己菜也没啥可说的。陆陆续续的笔试也接了不少，字节、京东、完美、西山居、WEBANK、360、阿里大大小小好几十家，线上的，线下的目前为止是一家门也没敲开。说实话一开始确实有些心高气傲，甚至还有点怨天尤人，但现在吧更多的感觉是自己的不足，真的前阵子觉得自己是一无是处，心里落差真的是很大。发现自己真的是很弱小，懂的太少，需要学的东西太多，很心急。再加上身边有拿到大厂offer的，甚至是好几家，说实话是真难受。 二、理性分析，给自己打气 &emsp;&emsp;不过难过是难过了点，我也却却实实的成长了不少，漫长的拉锯战使我学会了如何处理自己的情绪和压力。我也明白了饭始终是要一口一口吃的，这东西急不得，稳扎稳打慢慢来，也无需去和别人比较，因为人确实是和人不一样的。我所要做的就是在我自身情况的前提下，去做最大的努力。做好自己分内的是，我相信我会拿到我想要的东西的。 三、制定计划，成事在人 &emsp;&emsp;先给自己规划好，无需被别人打乱阵脚。你永远是你，你活不成别人别人也活不成你。 1234希望我可以把博客做下去，至少两天一章。（学会坚持第一件事，这很重要。）每天至少三道算法题。（先从剑指offer刷起，从哪跌倒从哪爬起来）抽出时间复习数据结构。（这个很重要，至少两天一节课，重点在树）每天三小时项目进行完善。项目大可不急但必须推进（负载均衡，以及文件传输） &emsp;&emsp;就这么多，这也不少。（切记不可因别人乱了自己的节奏，饭一口一口吃）。 &emsp;&emsp;不要做行动的矮子，不然我都看不起你！！！ 四、无需气馁，也没有必要 &emsp;&emsp;学到了那就是收获，不要心急，不要贪心。给自己的忠告。&emsp;&emsp;最后还是觉得很幸运，无意中做出这么个blog，我相信它会给我帮助的。加油。","categories":[{"name":"目标","slug":"目标","permalink":"http://yoursite.com/categories/目标/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"},{"name":"分析","slug":"分析","permalink":"http://yoursite.com/tags/分析/"}],"author":"yourenAs"},{"title":"分治大法好","slug":"分治大法好","date":"2019-04-10T14:54:22.000Z","updated":"2019-04-11T06:24:35.269Z","comments":true,"path":"2019/04/10/分治大法好/","link":"","permalink":"http://yoursite.com/2019/04/10/分治大法好/","excerpt":"一、分治法 &emsp;&emsp;一说起算法对我而言就不由的想起暴力、分治、回溯、动态规划、贪心、深度优先、广度优先等等，不过我一个都不精通。-V-!!。好了不扯了，进入正题，看标题“分治大法好”，为什么这么起嘞，是有原因的。博主今天在刷LeetCode的时候遇到了这么个题，合并K个有序链表，题号是23,我这里给了链接，有兴趣的可以去看看，我今天就来用分治的策略来分析一下这个题目。","text":"一、分治法 &emsp;&emsp;一说起算法对我而言就不由的想起暴力、分治、回溯、动态规划、贪心、深度优先、广度优先等等，不过我一个都不精通。-V-!!。好了不扯了，进入正题，看标题“分治大法好”，为什么这么起嘞，是有原因的。博主今天在刷LeetCode的时候遇到了这么个题，合并K个有序链表，题号是23,我这里给了链接，有兴趣的可以去看看，我今天就来用分治的策略来分析一下这个题目。 &emsp;&emsp;接下来就来针对这个题来分析一下。从比较简单的思想来逐渐深入。 二、思路&emsp;&emsp;（1）首先以我的角度第一个想法是先将第一个链表和第二个链表合并，然后再将合并好的链表与第三个链表去合并，依次类推就可将问题解决。但是这么做弊端也很明显就是时间复杂度比较大，假设链表长度都为N，那么时间复杂度应该为O(n!)，所以并不是很好的方法。&emsp;&emsp;（2）第二个就是归并的思想，也就是将第一个链表和第二个链表合并，再将第三个链表和第四个链表合并，依次类推，再将和并好的在合并就得到了最终的那个链表。这种时间复杂度相比上一个就要小一部分了。如图： &emsp;&emsp;（3）第三种就是使用堆这个数据结构，直接对k个链表同时依次向后遍历，那么时间复杂度应该在n(logn)可以说是最理想的一种方法了。 &emsp;&emsp;不过博主还未进一步了解这种处理方法，因为能将问题和数据结构联系到一块还不是博主所能触及到的区域。这里就提下，今天主要想说的是 关于第二种思路和分治结合在一起的处理方法。 三、分析&emsp;&emsp;当看到上面那个合并图的时候，相信敏感的同学很快就能发现这是一个树状的结构且还是最规矩的二叉树状，换言之就是“问题可分为若干个子问题，且子问题的解可构成原问题的解”，这是很明显的分治特征。看到这里那么问题解决思路就很清晰了。就是将K个链表分为两部分，然后递归下去就是问题的解了。这样表述是站在宏观的角度上的，可能有些人并不是很明白。没关系这很正常，你可以这么想，也就是将K看成2，也就是只有两条链表，然后将其合并，是不是就能理解开了。好了光说不练是不行的，上代码，结合代码可能就明白了。 四、代码这里我用的是c++不过语言大同小异，注重思想。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution&#123;public: ListNode* mergeTwoLists(ListNode* l1,ListNode* l2)&#123; //情况预处理以及递归结束条件 if(l1 == NULL) return l2; if(l2 == NULL) return l1; //这段代码也是相当精髓的。同样的你可以看作是l1和l2都只有一个节点。 ListNode* head = NULL; if(l1-&gt;value &lt;= l2-&gt;value) &#123; head = l1; head -&gt; next = mergeTwoLists(l1-&gt;next,l2); &#125; else &#123; head = l2; head -&gt; next = mergeTwoLists(l1,l2-&gt;next); &#125; return head; &#125; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)&#123; //情况预处理以及递归结束条件，基本每道题一开始都要考虑这个的。 if(lists.size()==0) return NULL; if(lists.size()==1) return lists[0]; if(lists.size()==2) return mergeTwoLists(lists[0],lists[1]); //一分为二 int mid = lists.size()/2; vector&lt;ListNode*&gt; l1(mid); vector&lt;ListNode*&gt; l2(lists.size()-mid); for(int i=0;i&lt;mid;i++) &#123; l1[i] = lists[i]; &#125; for(int j=mid;j&lt;lists.size();j++) &#123; l2[j-mid] = lists[j]; &#125; //这句算是整篇代码的精髓之体现了，递归千万不能深度分析，应该层次分析，就会很好理解。 //假设 K等2 实质上这句就是合并两个链表 l1,l2。 return mergeTwoLists(mergeKLists(l1),mergeKLists(l2)); &#125;&#125; 五、总结&emsp;&emsp;我觉得看到到这里大家应该就会明白我为什么要起这么个标题了，将实在的但我看到这种解法的时候真的惊到了，应为即使你有第二种思路但想将它用代码完整的翻译出来实质上是有一定难度的，少不免要出点小bug，但是加入分治思想后整体代码逻辑真的是非常清晰了，这段代码真的可以说是优美了，没有一点拖泥带水。而且难能可贵的是这道题目也是与分治异常的契合，将分治的思想可谓是发挥到了极致。当然这都是我的愚见。虽然效率上并不及第三种处理方法，不过我认为整体上堪称完美。可能是我阅历还太浅，但是这段代码真的有震撼到我。好了今天的分享就到这了。这也算是我真正意义上的第一篇博客了，希望大家喜欢。","categories":[{"name":"分治策略","slug":"分治策略","permalink":"http://yoursite.com/categories/分治策略/"}],"tags":[{"name":"分治策略","slug":"分治策略","permalink":"http://yoursite.com/tags/分治策略/"},{"name":"层次分析","slug":"层次分析","permalink":"http://yoursite.com/tags/层次分析/"},{"name":"合并链表","slug":"合并链表","permalink":"http://yoursite.com/tags/合并链表/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-04-08T14:04:22.272Z","updated":"2019-04-09T14:22:45.084Z","comments":true,"path":"2019/04/08/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hello World","slug":"我的第一篇博客文章","date":"2017-06-17T16:00:00.000Z","updated":"2019-04-10T06:15:51.589Z","comments":true,"path":"2017/06/18/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2017/06/18/我的第一篇博客文章/","excerpt":"MinHow-This is a summary","text":"MinHow-This is a summary","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[{"name":"First","slug":"First","permalink":"http://yoursite.com/tags/First/"},{"name":"Second","slug":"Second","permalink":"http://yoursite.com/tags/Second/"}],"author":"MinHow"}]}