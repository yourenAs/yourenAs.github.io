{"meta":{"title":"YourenAs","subtitle":null,"description":null,"author":"YourenAs","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"项目问题记录","slug":"关于迷你百度云项目问题解决","date":"2019-04-14T16:00:00.000Z","updated":"2019-04-16T01:56:04.379Z","comments":true,"path":"2019/04/15/关于迷你百度云项目问题解决/","link":"","permalink":"http://yoursite.com/2019/04/15/关于迷你百度云项目问题解决/","excerpt":"&emsp;&emsp;最近在做一个小项目算是模拟了FTP文件传输的过程，在这中间遇到了一些问题，今天就来总结一下这些问题顺便提下解决的办法。","text":"&emsp;&emsp;最近在做一个小项目算是模拟了FTP文件传输的过程，在这中间遇到了一些问题，今天就来总结一下这些问题顺便提下解决的办法。 一、问题 &emsp;&emsp;（1）客户端在与服务器建立连接后且在传输过程中，若客户端中止后服务器挂掉。&emsp;&emsp;（2）文件在传输到一半中止后，再次传输，如何传输（即断点续传问题）。&emsp;&emsp;（3）如何实现类似百度云的秒传功能。&emsp;&emsp;（4）在实现并发后，若有成千上万个用户同时下载同一个文件时，如何处理。 二、问题分析 &emsp;&emsp;第一个问题：&emsp;&emsp;首先，为什么在文件传输到一半的时候关掉客户端服务器会挂掉，终归原因是在于我在设计的时候是单方面一直发送，另一方面一直接受，若是两端都正常倒也没什么问题，但若某接受方突然挂掉那么就会导致发送方一直在send()所以进而就导致发送方也挂掉了。&emsp;&emsp;第二个问题：&emsp;&emsp;断点续传如何解决，断点续传的问题本质在于再次启动时并不知道上次文件传输到的位置，以及那个文件是不完整文件。解决这两个问题断点续传也就解决了。&emsp;&emsp;第三个问题：&emsp;&emsp;要解决第三个问题，就必须了解真正的秒传是怎样实现的，也就是并非真实的去上传，而是服务器端在已有资源的前提下为你提供了一个访问该资源的新接口，看似秒传，实则没传。&emsp;&emsp;第四个问题：&emsp;&emsp;很显然，若是访问量一旦飙升特别是对于同一文件，若是并发对其读取且发送是没法实现的。问题本质在于，如何解决多用户同时对于磁盘的某一区域的同时访问。 三、解决问题&emsp;&emsp;（1）原因分析出来后解决就容易多了，既然是因为发送端不知道接受端挂掉而导致的，那么解决办法也是不唯一的。 &emsp;&emsp;&emsp;①最简单的解决办法就是接受一波数据就像发送端回复一声，倘若挂掉自然会给发送端的recv()返回值必然是0，这样就可以解决这个问题了。&emsp;&emsp;&emsp;②稍微复杂一点，效率要比上一种好，就是使用IO复用，一直去监听套接字上的读写事件，因为发送端的写事件是一直是就绪的，所以可以一直发送，但只要接到读事件必然是接受端挂掉或者是其他异常操作导致的。 &emsp;&emsp;（2）解决这个问题方法也不唯一，不过在这里我就只提一种解决方案。&emsp;&emsp;&emsp;那就是通过类似操作系统上对于一个打开文件的处理，也就是会去产生一个中间文件。借由这种思路可以在一开始文件传输时，接收方在创建该文件时给其增添后缀标识其为一个未传输完的文件。例如:a.c.tmp运用.tmp去标识，传输完成后再去掉后缀名就ok了。如是挂掉重启，就去找带有.tmp后缀的文件将其文件大小发送给发送方，便可继续正常接受了。 &emsp;&emsp;（3）解决秒传我这目前只有一个思路，就是通过MD5将服务器上所有资源都处理一遍，形成一种Key_Value的映射关系，若是上传的Key值可以查到，则给用户提供一个软连接，可以让其访问，便解决了秒传这个问题。当然这并非完全解决，若是用户是以只读的方式使用该资源倒还罢了，若是要修改资源那便要加入写时拷贝的操作了。 &emsp;&emsp;（4）针对于第四个问题，目前也只有一个思路，就是类似内存池的处理一样。一次性拿到操作系统相应资源，由用户去控制分配。同样适用于这里的问题。之后有时间我再详细的写一篇博客，针对于这最后这一个问题，这里就提一下。","categories":[{"name":"项目","slug":"项目","permalink":"http://yoursite.com/categories/项目/"}],"tags":[{"name":"文件传输","slug":"文件传输","permalink":"http://yoursite.com/tags/文件传输/"},{"name":"问题解决","slug":"问题解决","permalink":"http://yoursite.com/tags/问题解决/"}],"author":"yourenAs"},{"title":"总结，目标","slug":"总结，目标","date":"2019-04-13T14:36:10.000Z","updated":"2019-04-13T15:38:43.764Z","comments":true,"path":"2019/04/13/总结，目标/","link":"","permalink":"http://yoursite.com/2019/04/13/总结，目标/","excerpt":"&emsp;&emsp;对自己这一个多月以来的回顾，还有对自己现状的剖析，以及今后该如何去做。","text":"&emsp;&emsp;对自己这一个多月以来的回顾，还有对自己现状的剖析，以及今后该如何去做。 一、回顾&emsp;&emsp;转眼春招开始已经一个多月了，自己除了接到腾讯一家面试之外，好像再都没了。说来也惭愧，被腾讯捞了又捞还是没能走到HR,自己菜也没啥可说的。陆陆续续的笔试也接了不少，字节、京东、完美、西山居、WEBANK、360、阿里大大小小好几十家，线上的，线下的目前为止是一家门也没敲开。说实话一开始确实有些心高气傲，甚至还有点怨天尤人，但现在吧更多的感觉是自己的不足，真的前阵子觉得自己是一无是处，心里落差真的是很大。发现自己真的是很弱小，懂的太少，需要学的东西太多，很心急。再加上身边有拿到大厂offer的，甚至是好几家，说实话是真难受。 二、理性分析，给自己打气 &emsp;&emsp;不过难过是难过了点，我也却却实实的成长了不少，漫长的拉锯战使我学会了如何处理自己的情绪和压力。我也明白了饭始终是要一口一口吃的，这东西急不得，稳扎稳打慢慢来，也无需去和别人比较，因为人确实是和人不一样的。我所要做的就是在我自身情况的前提下，去做最大的努力。做好自己分内的是，我相信我会拿到我想要的东西的。 三、制定计划，成事在人 &emsp;&emsp;先给自己规划好，无需被别人打乱阵脚。你永远是你，你活不成别人别人也活不成你。 1234希望我可以把博客做下去，至少两天一章。（学会坚持第一件事，这很重要。）每天至少三道算法题。（先从剑指offer刷起，从哪跌倒从哪爬起来）抽出时间复习数据结构。（这个很重要，至少两天一节课，重点在树）每天三小时项目进行完善。项目大可不急但必须推进（负载均衡，以及文件传输） &emsp;&emsp;就这么多，这也不少。（切记不可因别人乱了自己的节奏，饭一口一口吃）。 &emsp;&emsp;不要做行动的矮子，不然我都看不起你！！！ 四、无需气馁，也没有必要 &emsp;&emsp;学到了那就是收获，不要心急，不要贪心。给自己的忠告。&emsp;&emsp;最后还是觉得很幸运，无意中做出这么个blog，我相信它会给我帮助的。加油。","categories":[{"name":"目标","slug":"目标","permalink":"http://yoursite.com/categories/目标/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"},{"name":"分析","slug":"分析","permalink":"http://yoursite.com/tags/分析/"}],"author":"yourenAs"},{"title":"分治大法好","slug":"分治大法好","date":"2019-04-10T14:54:22.000Z","updated":"2019-04-11T06:24:35.269Z","comments":true,"path":"2019/04/10/分治大法好/","link":"","permalink":"http://yoursite.com/2019/04/10/分治大法好/","excerpt":"一、分治法 &emsp;&emsp;一说起算法对我而言就不由的想起暴力、分治、回溯、动态规划、贪心、深度优先、广度优先等等，不过我一个都不精通。-V-!!。好了不扯了，进入正题，看标题“分治大法好”，为什么这么起嘞，是有原因的。博主今天在刷LeetCode的时候遇到了这么个题，合并K个有序链表，题号是23,我这里给了链接，有兴趣的可以去看看，我今天就来用分治的策略来分析一下这个题目。","text":"一、分治法 &emsp;&emsp;一说起算法对我而言就不由的想起暴力、分治、回溯、动态规划、贪心、深度优先、广度优先等等，不过我一个都不精通。-V-!!。好了不扯了，进入正题，看标题“分治大法好”，为什么这么起嘞，是有原因的。博主今天在刷LeetCode的时候遇到了这么个题，合并K个有序链表，题号是23,我这里给了链接，有兴趣的可以去看看，我今天就来用分治的策略来分析一下这个题目。 &emsp;&emsp;接下来就来针对这个题来分析一下。从比较简单的思想来逐渐深入。 二、思路&emsp;&emsp;（1）首先以我的角度第一个想法是先将第一个链表和第二个链表合并，然后再将合并好的链表与第三个链表去合并，依次类推就可将问题解决。但是这么做弊端也很明显就是时间复杂度比较大，假设链表长度都为N，那么时间复杂度应该为O(n!)，所以并不是很好的方法。&emsp;&emsp;（2）第二个就是归并的思想，也就是将第一个链表和第二个链表合并，再将第三个链表和第四个链表合并，依次类推，再将和并好的在合并就得到了最终的那个链表。这种时间复杂度相比上一个就要小一部分了。如图： &emsp;&emsp;（3）第三种就是使用堆这个数据结构，直接对k个链表同时依次向后遍历，那么时间复杂度应该在n(logn)可以说是最理想的一种方法了。 &emsp;&emsp;不过博主还未进一步了解这种处理方法，因为能将问题和数据结构联系到一块还不是博主所能触及到的区域。这里就提下，今天主要想说的是 关于第二种思路和分治结合在一起的处理方法。 三、分析&emsp;&emsp;当看到上面那个合并图的时候，相信敏感的同学很快就能发现这是一个树状的结构且还是最规矩的二叉树状，换言之就是“问题可分为若干个子问题，且子问题的解可构成原问题的解”，这是很明显的分治特征。看到这里那么问题解决思路就很清晰了。就是将K个链表分为两部分，然后递归下去就是问题的解了。这样表述是站在宏观的角度上的，可能有些人并不是很明白。没关系这很正常，你可以这么想，也就是将K看成2，也就是只有两条链表，然后将其合并，是不是就能理解开了。好了光说不练是不行的，上代码，结合代码可能就明白了。 四、代码这里我用的是c++不过语言大同小异，注重思想。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution&#123;public: ListNode* mergeTwoLists(ListNode* l1,ListNode* l2)&#123; //情况预处理以及递归结束条件 if(l1 == NULL) return l2; if(l2 == NULL) return l1; //这段代码也是相当精髓的。同样的你可以看作是l1和l2都只有一个节点。 ListNode* head = NULL; if(l1-&gt;value &lt;= l2-&gt;value) &#123; head = l1; head -&gt; next = mergeTwoLists(l1-&gt;next,l2); &#125; else &#123; head = l2; head -&gt; next = mergeTwoLists(l1,l2-&gt;next); &#125; return head; &#125; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)&#123; //情况预处理以及递归结束条件，基本每道题一开始都要考虑这个的。 if(lists.size()==0) return NULL; if(lists.size()==1) return lists[0]; if(lists.size()==2) return mergeTwoLists(lists[0],lists[1]); //一分为二 int mid = lists.size()/2; vector&lt;ListNode*&gt; l1(mid); vector&lt;ListNode*&gt; l2(lists.size()-mid); for(int i=0;i&lt;mid;i++) &#123; l1[i] = lists[i]; &#125; for(int j=mid;j&lt;lists.size();j++) &#123; l2[j-mid] = lists[j]; &#125; //这句算是整篇代码的精髓之体现了，递归千万不能深度分析，应该层次分析，就会很好理解。 //假设 K等2 实质上这句就是合并两个链表 l1,l2。 return mergeTwoLists(mergeKLists(l1),mergeKLists(l2)); &#125;&#125; 五、总结&emsp;&emsp;我觉得看到到这里大家应该就会明白我为什么要起这么个标题了，将实在的但我看到这种解法的时候真的惊到了，应为即使你有第二种思路但想将它用代码完整的翻译出来实质上是有一定难度的，少不免要出点小bug，但是加入分治思想后整体代码逻辑真的是非常清晰了，这段代码真的可以说是优美了，没有一点拖泥带水。而且难能可贵的是这道题目也是与分治异常的契合，将分治的思想可谓是发挥到了极致。当然这都是我的愚见。虽然效率上并不及第三种处理方法，不过我认为整体上堪称完美。可能是我阅历还太浅，但是这段代码真的有震撼到我。好了今天的分享就到这了。这也算是我真正意义上的第一篇博客了，希望大家喜欢。","categories":[{"name":"分治策略","slug":"分治策略","permalink":"http://yoursite.com/categories/分治策略/"}],"tags":[{"name":"分治策略","slug":"分治策略","permalink":"http://yoursite.com/tags/分治策略/"},{"name":"层次分析","slug":"层次分析","permalink":"http://yoursite.com/tags/层次分析/"},{"name":"合并链表","slug":"合并链表","permalink":"http://yoursite.com/tags/合并链表/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-04-08T14:04:22.272Z","updated":"2019-04-09T14:22:45.084Z","comments":true,"path":"2019/04/08/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hello World","slug":"我的第一篇博客文章","date":"2017-06-17T16:00:00.000Z","updated":"2019-04-10T06:15:51.589Z","comments":true,"path":"2017/06/18/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2017/06/18/我的第一篇博客文章/","excerpt":"MinHow-This is a summary","text":"MinHow-This is a summary","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[{"name":"First","slug":"First","permalink":"http://yoursite.com/tags/First/"},{"name":"Second","slug":"Second","permalink":"http://yoursite.com/tags/Second/"}],"author":"MinHow"}]}